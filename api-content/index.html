{"posts":[{"title":"图论算法集合","content":"GMQ出品，图论算法思想，例题及代码详解 My Github Blog： 【图论算法】拓扑排序 【图论算法】最小生成树（MST） 【图论算法】最短路径&lt;==由于Latax公式渲染失效，请在洛谷博客查看 My Luogu Blog： 【图论算法】拓扑排序 【图论算法】最小生成树（MST） 【图论算法】最短路径 My UOJ Blog： 【图论算法】拓扑排序 【图论算法】最小生成树（MST） 持续更新中…… ","link":"https://gaomaoqi.github.io/post/tu-lun-suan-fa-ji-he/"},{"title":"【图论算法】最短路径","content":"一、最短路径的定义 对在有权图G=(V,E)G=(V,E)G=(V,E)，从一个源点s到汇点t有很多条路径，其中路径上权值和最小的路径，称从s到t的最短路径。 简单讲：找出连接两个给定顶点权值和最小的路径。 二、最短路径问题的分类及算法 SSSP：求给定起点S到其他所有点的最短路，常见算法有Dijkstra算法、Bellman_Ford算法及SPFA算法； APSP：求任意两对顶点之间的最短路，常见算法有Floyd算法； 这两种情况在做题时一定要分清 （一）Floyd算法（APSP） 算法概述 Floyd算法借助DP思想，可以求出每对点之间的最短距离，它对于图的要求是，可以是无向图和有向图，边权可正可负，唯一的要求是不能有负环。 算法原理 定义 d[i][j][k]d[i][j][k]d[i][j][k] 为路径中间只允许经过节点1...k1...k1...k的情况下，i到j的最短路距离。 它有两种情况： 最短路经过点k，d[i][j][k]=d[i][k][k−1]+d[k][j][k−1]d[i][j][k]=d[i][k][k-1]+d[k][j][k-1]d[i][j][k]=d[i][k][k−1]+d[k][j][k−1] 最短路不经过点k，d[i][j][k]=d[i][j][k−1]d[i][j][k]=d[i][j][k-1]d[i][j][k]=d[i][j][k−1] 综合起来，状态转移方程为： d[i][j][k]=min{d[i][k][k−1]+d[k][j][k−1],d[i][j][k−1]}d[i][j][k]=min\\left\\{d[i][k][k-1]+d[k][j][k-1],d[i][j][k-1] \\right\\}d[i][j][k]=min{d[i][k][k−1]+d[k][j][k−1],d[i][j][k−1]} 边界条件：d[i][j][0]=len[i][j]d[i][j][0]=len[i][j]d[i][j][0]=len[i][j]（不存在的边权可为∞）相信大家已经看出来，我们实际上只是做了一次动态规划。由于在递推过程中k是递增的，所以我们只需要一个二维数组就可以了。 具体来说就是：初始d[i][j]=w[i][j]d[i][j]=w[i][j]d[i][j]=w[i][j]。从小到大枚举k，对每对结点(u,v)(u,v)(u,v)，检查更新它们的最短路值。 核心代码 非常简单粗暴，时间复杂度：O(n3)O(n^3)O(n3) for(k=1;k&lt;=n;k++) //枚举中间点 for(i=1;i&lt;=n;i++) //枚举起点 for(j=1;j&lt;=n;j++) //枚举终点 if((d[i][k]!=INF)&amp;&amp;(d[k][j]!=INF)&amp;&amp;(d[i][k]+d[k][j]&lt;d[i][j])) d[i][j]=d[i][k]+d[k][j]; 该算法例题 1624 -- 【模拟试题】图的直径 Description 图的直径是这样定义的：在一个带正权的图中，它的直径是指任意两点之间最短路的最大距离。注意：此图为无向图。 Input 第一行有两个正整数N,M,分别表示点数和边数(N&lt;=100,M&lt;=10000）。 接下来M行，每行三个正整数，分别表示每一条边的两个端点编号和长度。 Output 输出只有一行为这个图的直径。 Sample Input 3 3 1 2 1 2 3 2 1 3 2 Sample Output 2 这显然是APSP​，即任意两对顶点之间的最短路 代码实现： 初始化d[i][j]={0i=j∞i≠jd[i][j]=\\begin{cases}0&amp;i=j\\\\∞&amp;i\\ne j\\end{cases}d[i][j]={0∞​i=ji​=j​ 读入数据 跑一遍Floyd 枚举结点iii和点jjj，找到d[i][j]d[i][j]d[i][j]的最大值并输出 由于上面已经说的很清楚了，所以代码里面没有太多注释 #include&lt;iostream&gt; #include&lt;cstdio&gt; #define maxn 5003 #define yao_bu_ke_ji 0x3f3f3f3f using namespace std; int n,m; int fd[maxn][maxn]; int floyed() { for(int mid=1; mid&lt;=n; mid++) { for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { if(fd[i][mid]&lt;yao_bu_ke_ji-5&amp;&amp;fd[mid][j]&lt;yao_bu_ke_ji-5) { fd[i][j]=min(fd[i][j],fd[i][mid]+fd[mid][j]); } } } } } int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { if(i==j) fd[i][j]=0; else fd[i][j]=yao_bu_ke_ji; } } for(int i=1; i&lt;=m; i++) { int x,y; cin&gt;&gt;x&gt;&gt;y; cin&gt;&gt;fd[x][y];//cin要 分开写！ 分开写！ 分开写！ fd[y][x]=fd[x][y]; } floyed(); int ans=-yao_bu_ke_ji; for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { if(fd[i][j]&lt;yao_bu_ke_ji-3) ans=max(ans,fd[i][j]); } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } 选址类问题 现准备在n个居民点v1,v2,...,vn中设置一银行，问设在哪个点，可使最大服务距离最小？ 若设置两个银行，问设在哪两个点? 假设各个居民点都有条件设置银行，并有路相连，且路长已知。实质就是求图的中心问题。 设置一个银行的情况： 初始化d[i][j]={0i=j∞i≠jd[i][j]=\\begin{cases}0&amp;i=j\\\\∞&amp;i\\ne j\\end{cases}d[i][j]={0∞​i=ji​=j​ 读入数据，邻接矩阵存储； 用Floyd求任意两点间的最短距离d[i][j]d[i][j]d[i][j]； 枚举点iii，找到其它点的最短路径的最大值，即t[i]=max{t[i],d[i][j]}(1≤j≤n)t[i]=max \\left\\{t[i],d[i][j]\\right\\}(1\\le j\\le n)t[i]=max{t[i],d[i][j]}(1≤j≤n) ans=min{ans,t[i]}(1≤i≤n)ans=min \\left\\{ans,t[i]\\right\\}(1\\le i\\le n)ans=min{ans,t[i]}(1≤i≤n) #include&lt;iostream&gt; #include&lt;cstdio&gt; #define maxn 6120 #define sky 0x7fffffff/2 using namespace std; int n,m; int fd[maxn][maxn]; void floyed() { for(int mid=1; mid&lt;=n; mid++) { for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { if(fd[i][mid]&lt;sky-3&amp;&amp;fd[mid][j]&lt;sky-3) { fd[i][j]=min(fd[i][j],fd[i][mid]+fd[mid][j]); } } } } } int main() { cin&gt;&gt;n; m=n-1; for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { if(i==j) fd[i][j]=0; else fd[i][j]=sky; } } for(int i=1; i&lt;=m; i++) { int x,y; cin&gt;&gt;x&gt;&gt;y; cin&gt;&gt;fd[x][y]; fd[y][x]=fd[x][y]; } floyed(); int anss[maxn]; for(int i=1; i&lt;=n; i++) { int ans=-sky; for(int j=1; j&lt;=n; j++) { if(fd[i][j]&lt;sky-3) ans=max(ans,fd[i][j]); } anss[i]=ans; } int reans=sky,aans; for(int i=1; i&lt;=n; i++) { // reans=min(anss[i],reans); if(anss[i]&lt;reans) { reans=anss[i]; aans=i; } } cout&lt;&lt;aans; return 0; } 设置两个银行的情况 初始化d[i][j]={0i=j∞i≠jd[i][j]=\\begin{cases}0&amp;i=j\\\\∞&amp;i\\ne j\\end{cases}d[i][j]={0∞​i=ji​=j​ 读入数据，邻接矩阵存储； 设两个银行设置在点iii和点jjj,枚举kkk（居民点），求出到jjj距离的最小值，再找出所有kkk中最大值，即为在i,ji,ji,j设置银行的最大服务距离：t[i][j]=max{t[i][j],min(d[i][k],d[j][k])(1≤k≤n)}(1≤i&lt;j≤n)t[i][j]=max \\left\\{t[i][j],min(d[i][k],d[j][k])(1\\le k \\le n)\\right\\}(1\\le i&lt;j\\le n)t[i][j]=max{t[i][j],min(d[i][k],d[j][k])(1≤k≤n)}(1≤i&lt;j≤n) ans=min{ans,t[i][j]}(1≤i&lt;j≤n)ans=min \\left\\{ans,t[i][j]\\right\\}(1\\le i&lt;j\\le n)ans=min{ans,t[i][j]}(1≤i&lt;j≤n) 代码走丢了 （二）Dijkstra算法（SSSP） 算法思想 如果图是不带负权的有向图或者无向图，我们可以用类似Prim算法的贪心思想，从起点v0v0v0每次新扩展一个距离最短的点，再以这个点为中间点，更新起点到其他所有点的距离。由于所有边权都为正，故不会存在一个距离更短的没被扩展过的点，所以这个点的距离永远不会再被改变，因而保证了算法的正确性。 算法实现时，用一维数组vst[i]vst[i]vst[i]表示源点到顶点i的最短距离求出没有。用d[i]d[i]d[i]记录源点v0v0v0到顶点iii的距离值。 算法步骤 初始化d[v0]=0d[v0]=0d[v0]=0，源点到其它点的距离值d[i]=∞d[i]=∞d[i]=∞； 经过nnn次如下步骤操作，最后得到v0v0v0到nnn个顶点的最短距离； A. 选择一个未标记的点kkk并且d[k]d[k]d[k]的值是最小的； B. 标记点kkk，即vst[k]=1vst[k]=1vst[k]=1； C. 以kkk为中间点，修改源点v0v0v0到其他未标记点jjj的距离值d[j]d[j]d[j] ","link":"https://gaomaoqi.github.io/post/tu-lun-suan-fa-zui-duan-lu-jing/"},{"title":"【图论算法】最小生成树（MST）","content":"GMQ出品，最小生成树（MST）概念、算法、基础例题及代码详解 一、生成树的定义 生成树：一个|V|个点的无向连通图中，取其中|V|-1条边，并连接所有的顶点，则为原图的一棵生成树。 树的属性：树是图的一种特殊形态。一个图G是树当且仅当以下任意一个条件成立： G有V-1条边，无圈； G有V-1条边，连通； 任意两点只有唯一的简单路径； G连通，但任意删除一条边后不连通； 二、最小生成树的定义 最小生成树：在一张带权的无向连通图中，各边权和为最小的一棵生成树即为最小生成树。 简单讲：找出连接所有点的最低成本路线 示意图： 红边连接了所有顶点， 所以构成一棵生成树， 权和=1+2+2+4+4+7+8+9。 三、最小生成树的特性 环属性：一棵生成树上，增加一条边e，再删除e所在环上的最大边，会得到另一棵“更好”的生成树(如果e不是最大边) 剪切属性：在图中，剪切将顶点划分成两个不相交集合。交叉边为这些顶点在两个不同集合的边。对于任何一个剪切，各条最小的交叉边都属于某个MST，且每个MST中都包含一条最小交叉边。 最小边原则：图中权值最小的边(如果唯一的话)一定在最小生成树上。 唯一性：一棵生成树上，如果各边的权都不相同，则最小生成树是唯一的。反之不然。 四、最小生成树的算法 无向图的最小生成树（贪心思想） Kruskal算法，适用于边少的图 Prim算法，适用于点少的图 Kruskal算法 算法思想 Kruskal算法是一种贪心算法，它是将边按权值排序，每次从剩下的边集中选择权值最小且两个端点不在同一集合的边加入生成树中，反复操作，直到加入了n-1条边。 算法步骤 将图G中的边按权值从小到大排序； 按照权值从小到大依次选边。若当前选取的边加入后使生成树T形成环，则舍弃当前边；否则标记当前边并计数； 重复“2”的操作，直到生成树T中包含n-1条边为止。否则当遍历完所有的边后，都不能选取n-1条边，表示最小生成树不存在。 算法的关键在于如何判定新加入的边会不会使图G‘产生环，在这里使用并查集，如果新加入边的两个端点在并查集的同一个集合中，说明存在环，需要舍弃这条边；否则保留当前边，并合并涉及的两个集合。用并查集优化后总的时间复杂度为O(mlogm+mα(n)) 算法核心代码 bool cmp(constEdge &amp;x,constEdge &amp;y) {return x.z&lt;y.z;} int Getfather(int x) {//查找祖先 if(prt[x]==x)return x; prt[x]=Getfather(prt[x]); return prt[x]; } void kruskal() {//kruskal核心程序 intf1,f2,k,i;k=0; for(i=1;i&lt;=n;i++)prt[i]=i;//初始化 for(i=1;i&lt;=m;i++) { f1=Getfather(a[i].x); f2=Getfather(a[i].y); if(f1!=f2){//非环 ans=ans+a[i].z; prt[f1]=f2;//合并不相同的两个集合 k++; if(k==n-1) break; } } if(k&lt;n-1) { cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl; bj=0; return; } } int main(){ cin&gt;&gt;n&gt;&gt;m; ans=0; bj=1; for(inti=1;i&lt;=m;i++)cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].z;//结构体存储 sort(a+1,a+m+1,cmp); kruskal(); if(bj)cout&lt;&lt;ans&lt;&lt;endl; } 该算法例题 1452 -- 【MST练习】修复公路2988 Description A地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。 给出A地区的村庄数N，和公路数M，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路） Input 第1行两个正整数N，M（N&lt;=1000，M&lt;=100000） 下面M行，每行3个正整数x, y, t，告诉你这条公路连着x,y两个村庄，在时间t时能修复完成这条公路。（x&lt;=N，y&lt;=N，t&lt;=100000） Output 如果全部公路修复完毕仍然存在两个村庄无法通车，则输出-1，否则输出最早什么时候任意两个村庄能够通车。 Sample Input 4 4 1 2 6 1 3 4 1 4 5 4 2 3 Sample Output 5 显然，这道题应该输出的是接边最大时间（即权值） 代码如下（注意注释内容）： #include&lt;bits/stdc++.h&gt; #define maxn 100010 using namespace std; struct star{ int x,y,k; }a[maxn]; bool did(star ax,star by) { return ax.k&lt;by.k; } int fa[maxn];//并查集 int getf(int x) { if(fa[x]==x) { return x; } else { fa[x]=getf(fa[x]); return fa[x]; } } int n,m; int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) { fa[i]=i; } for(int i=1; i&lt;=m; i++) { cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].k;//结构体存边 } sort(a+1,a+m+1,did); int sum=0;//记录接边次数 int t=0;//记录接边最大时间 for(int i=1; i&lt;=m+1; i++) {//Kruskal算法过程 if(i==m+1) {//无法生成 cout&lt;&lt;&quot;-1&quot;; return 0; } if(sum&gt;=n-1) break;//已经生成 if(getf(a[i].x)!=getf(a[i].y)) {//非环 sum++;//记录接边次数 fa[getf(a[i].x)]=getf(a[i].y);//合并 t=max(t,a[i].k);//针对本题记录接边最大时间 } if(sum&gt;=n-1) break;//已经生成 } cout&lt;&lt;t&lt;&lt;endl;//输出接边最大时间 return 0; } 1455 -- 【MST练习】联络员 Description Tyvj已经一岁了，网站也由最初的几个用户增加到了上万个用户，随着Tyvj网站的逐步壮大，管理员的数目也越来越多，现在你身为Tyvj管理层的联络员，希望你找到一些通信渠道，使得管理员两两都可以联络（直接或者是间接都可以）。Tyvj是一个公益性的网站，没有过多的利润，所以你要尽可能的使费用少才可以。 目前你已经知道，Tyvj的通信渠道分为两大类，一类是必选通信渠道，无论价格多少，你都需要把所有的都选择上；还有一类是选择性的通信渠道，你可以从中挑选一些作为最终管理员联络的通信渠道。数据保证给出的通行渠道可以让所有的管理员联通。 Input 第一行n，m表示Tyvj一共有n个管理员，有m个通信渠道; 第二行到m+1行，每行四个非负整数，p,u,v,w 当p=1时，表示这个通信渠道为必选通信渠道；当p=2时，表示这个通信渠道为选择性通信渠道；u,v,w表示本条信息描述的是u，v管理员之间的通信渠道，u可以收到v的信息，v也可以收到u的信息，w表示费用。 Output 输出仅一个整数表示最小的通信费用。 Sample Input 5 6 1 1 2 1 1 2 3 1 1 3 4 1 1 4 1 1 2 2 5 10 2 2 5 5 Sample Output 9 Hint 【样例解释】 1-2-3-4-1存在四个必选渠道，形成一个环，互相可以到达。需要让所有管理员联通，需要联通2号和5号管理员，选择费用为5的渠道，所以总的费用为9。 【注意】 U,v之间可能存在多条通信渠道，你的程序应该累加所有u,v之间的必选通行渠道 【数据范围】 对于30%的数据，n&lt;=10，m&lt;=100 对于50%的数据, n&lt;=200，m&lt;=1000 对于100%的数据，n&lt;=2000，m&lt;=10000 这道题存在“必选通信渠道”，但我们的解决方式也简单粗暴——直接连接解决一切（但是别忘了必选通道的价格应该计入答案） 代码如下： #include&lt;bits/stdc++.h&gt; #define maxn 100010 using namespace std; struct star{ int x,y,k; }a[maxn]; bool did(star ax,star by) { return ax.k&lt;by.k; } int fa[maxn];//并查集 int getf(int x) { if(fa[x]==x) { return x; } else { fa[x]=getf(fa[x]); return fa[x]; } return 0x7fffffff;//这是不可能执行的（划掉 } int n,m; int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) { fa[i]=i; } int ans=0;//记录权值和 for(int i=1; i&lt;=m; i++) { int p,u,v,w; cin&gt;&gt;p; if(p==1) {//必选通道，直接连接 cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; fa[getf(u)]=getf(v); ans+=w; } else cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].k; } sort(a+1,a+m+1,did); int sum=0;//记录接边次数 for(int i=1; i&lt;=m; i++) { if(sum&gt;=n-1) break; if(getf(a[i].x)!=getf(a[i].y)) { sum++; fa[getf(a[i].x)]=getf(a[i].y); ans+=a[i].k; } if(sum&gt;=n-1) break; } cout&lt;&lt;ans&lt;&lt;endl; return 0; } Prim算法 算法步骤 将1号节点置入集合S中。 找到所有连接S中的节点和非S中的节点的边中的权值最小的那一条，并标记这条边，同时将连接的非S中的节点加入S集合。 重复“2”步骤，直到所有节点都在S中了。 任意时刻的中间结果都是一棵树：从某一个点开始，每次都花最小的代价，用一条边加进一个新的点。 证明过程 这里啥也没有 核心代码 这不是我的码风 int vst[505];//vst[i]标记顶点i是否加入最小生成树中 int d[505];//d[i]表示不是生成树中点i到当前生成树中点到最小值 int g[505][505],n,m,ans=0; void Read()//读入数据,构建图 { inti,j,x,y,w; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++)g[i][j]=INF; for(i=1;i&lt;=m;i++){cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;g[x][y]=g[y][x]=w;} } void Prim(intv0){ inti,j,k,minn;memset(vst,0,sizeof(vst)); //初始化生成树点集合 for(i=1;i&lt;=n;i++)d[i]=INF;d[v0]=0;ans=0;for(i=1;i&lt;=n;i++) //选择n个点 { minn=INF; for(j=1;j&lt;=n;j++)//选择最小边if(vst[j]==0 &amp;&amp; minn&gt;d[j]) { minn=d[j]; k=j; } vst[k]=1; //标记 ans+=d[k];for(j=1;j&lt;=n;j++) //修改d数组 if(vst[j]==0&amp;&amp;d[j]&gt;g[k][j])d[j]=g[k][j]; } } int main(){ Read(); Prim(1); cout&lt;&lt;ans&lt;&lt;endl; } 优化方法 该算法例题 1450 -- 【MST练习】局域网1123 Description 某个局域网内有n(n&lt;=100)台计算机，由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用f(i,j)表示i,j之间连接的畅通程度(f(i,j)&lt;=1000)，f(i,j)值越小表示i,j之间连接越通畅，f(i,j)为0表示i,j之间无网线连接。现在我们需要解决回路问题，我们将除去一些连线，使得网络中没有回路，并且被除去网线的Σf(i,j)最大，请求出这个最大值。 Input 第一行两个正整数n和k； 接下来的k行每行三个正整数i j m，表示i,j两台计算机之间有网线联通，通畅程度为m。 Output 输出仅一个正整数，Σf(i,j)的最大值 Sample Input 5 5 1 2 8 1 3 1 1 5 3 2 4 5 3 4 2 Sample Output 8 废话少说，上代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #define maxn 5010 #define yao_bu_ke_ji 0x3f3f3f3f//其实就是inf啦~~ using namespace std; bool join[maxn]; int d[maxn]; int am[maxn][maxn];//邻接矩阵 int n,m; int prim() { int minn=yao_bu_ke_ji; for(int i=1; i&lt;=n; i++) { d[i]=yao_bu_ke_ji; } d[1]=0; int ans=0,jo; for(int i=1; i&lt;=n; i++) { minn=yao_bu_ke_ji; for(int j=1; j&lt;=n; j++) { if(join[j]==0) {//未加入集合 if(d[j]&lt;minn) {//边权小 minn=d[j];//更新 jo=j; } } } join[jo]=1;//标记 ans+=d[jo]; for(int j=1; j&lt;=n; j++) { if(join[j]==0) { d[j]=min(am[jo][j],d[j]);//更新d[] } } } return ans; } int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { am[i][j]=yao_bu_ke_ji;//初始化为inf } } int sum=0;//记录总权值 for(int i=1; i&lt;=m; i++) { int x,y,k; cin&gt;&gt;x&gt;&gt;y&gt;&gt;k; am[x][y]=k; am[y][x]=k; sum+=k; } cout&lt;&lt;sum-prim();//总权值减去保留权值得到答案 return 0; } 1451 -- 【MST练习】繁忙的都市（SCOI2005）1406 Description 城市C是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市C的道路是这样分布的：城市中有n个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求： 1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。 2．在满足要求1的情况下，改造的道路尽量少。 3．在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小。 任务：作为市规划局的你，应当作出最佳的决策，选择那些道路应当被修建。 Input 第一行有两个整数n,m表示城市有n个交叉路口，m条道路。 接下来m行是对每条道路的描述，u, v, c表示交叉路口u和v之间有道路相连，分值为c。(1≤n≤300，1≤c≤10000，1≤m≤8000) Output 输出两个整数s, max，表示你选出了几条道路，分值最大的那条道路的分值是多少。 Sample Input 4 5 1 2 3 1 4 5 2 4 7 2 3 6 3 4 8 Sample Output 3 6 代码来咯（注释请参考上一题）： #include&lt;iostream&gt; #include&lt;cstdio&gt; #define maxn 5010 #define yao_bu_ke_ji 0x3f3f3f3f using namespace std; bool join[maxn]; int d[maxn]; int am[maxn][maxn];//邻接矩阵 int n,m; int anm,anss; int prim() { int minn=yao_bu_ke_ji; for(int i=1; i&lt;=n; i++) { d[i]=yao_bu_ke_ji; } d[1]=0; int ans=0,jo; for(int i=1; i&lt;=n; i++) { minn=yao_bu_ke_ji; for(int j=1; j&lt;=n; j++) { if(join[j]==0) { if(d[j]&lt;minn) { minn=d[j]; jo=j; } } } anm=max(anm,d[jo]); anss++; join[jo]=1; ans+=d[jo]; for(int j=1; j&lt;=n; j++) { if(join[j]==0) { d[j]=min(am[jo][j],d[j]); } } } return ans; } int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { am[i][j]=yao_bu_ke_ji; } } for(int i=1; i&lt;=m; i++) { int x,y,k; cin&gt;&gt;x&gt;&gt;y&gt;&gt;k; am[x][y]=k; am[y][x]=k; } int did=prim(); cout&lt;&lt;anss-1&lt;&lt;&quot; &quot;&lt;&lt;anm; return 0; } 图片来源：Did's 课件 题目来源：Did及Xinyue 代码：GMQ原创出品 代码详解/注释：GMQ原创出品 有转载需求请私信：gao.maoqi.2007@foxmail.com ","link":"https://gaomaoqi.github.io/post/mst/"},{"title":"【图论算法】拓扑排序","content":"GMQ出品，拓扑排序的概念、堆优化、基础例题及代码详解 一、什么是拓扑排序 在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件： 每个顶点出现且只出现一次。 若存在一条从顶点A到顶点B的路径，那么在序列中顶点A出现在顶点B的前面。 有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。 例如，下面这个图： 对于本图而言:它是一个DAG图，那么如何写出它的拓扑排序呢？ 一种比较常用的方法： 从DAG图中选择一个没有前驱（即入度为0）的顶点并输出。 从图中删除该顶点和所有以它为起点的有向边。 重复1和2直到当前的DAG图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。 经过如下操作后： 得到拓扑排序后的结果是{1,2, 4, 3, 5}。 通常，一个有向无环图可以有一个或多个拓扑排序序列。 再来一个例子： 二、例题 模板题：1462 -- 【拓扑排序】拓扑排序 [问题描述] 给你一个图，要求你求出拓扑序列。 [输入格式] 第1行为2个空格分开的整数n(2&lt;=n&lt;=200)和m(10&lt;=m&lt;=20000)，分别表示图的顶点数和边数。 第2...m+1行，每行2个空格分开的整数i, j, i表示一条边的起点，j表示终点。 [输出格式] 拓扑序，顶点从1开始编号，若有多个拓扑序，则顶点编号小的优先输出。 若有环，则输出&quot;no solution&quot;。 [样例输入] 22 12 21 [样例输出] no solution 代码如下（按照最小字典序输出）复杂度为O(N2)： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; int n,m; int rd[410],ans[410]; bool mapp[410][410]; int tp() { for(int i=1; i&lt;=n; i++) { int k; for(k=1; k&lt;=n+1; k++) {//寻找入度为0的点 if(rd[k]==0) { break; } } if(k&gt;n) return 0;//环! ans[++ans[0]]=k;//按照最小字典序记录拓扑序列 rd[k]=-1;//标记入度为-1（注：千万不能标记为0） for(int j=1; j&lt;=n; j++) { if(mapp[k][j]==1) rd[j]--;//删除连边 } } return 1; } int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=m; i++) { int x,y; cin&gt;&gt;x&gt;&gt;y; rd[y]++;//统计入度 mapp[x][y]=1;//邻接矩阵存储 } if(tp()) {//无环 for(int i=1; i&lt;=ans[0]; i++) { cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; } return 0; } cout&lt;&lt;&quot;no solution&quot;&lt;&lt;endl;//有环 return 0; } 变形题：1464 -- 【拓扑排序】被遗忘的时光 [问题描述] Lost-Monkey赢了精灵，精灵告诉Lost-Monkey，神庙里被恶魔封印了一个名为Lostangle的天使，如果想把它释放出来，需要将 n 个时间点排序，而精灵只知道 m 条形如 a 在 b 前的信息。 Lost-Monkey一听到有天使，很想见见天使到底长什么样，可惜时间点太多，他觉得这几乎是不可能的任务，好在身为在他旁边的XXX，你，传说中的impossible is nothing，一定知道如何解决啦！！ [输入格式] 第一行n，m； 接下来m行，每行2个数a，b；意义均同上。 [输出格式] 输出文件仅一行，若可以将n个时间点排序，则输出字典序最小的一种方案，否则输出“NO SOLUTION”。 [样例输入] 3 2 1 2 2 3 [样例输出] 1 2 3 [数据范围] 40%的数据,n&lt;=1000，m&lt;=1000 100%的数据,n&lt;=100000，m&lt;=500000 这道题结点数n&lt;=100000 若为了保证字典序最小，按照上一道题的邻接矩阵实现方法时间复杂度为O(N2)，必然TLE 可以改进入度为0的点的汇总方式，不跑循环，而是在断边时判断并存储 但如果只用数组存储，虽然复杂度降到了O(n+e)，但是不能按照字典序 这是因为取出入度为0的点时是直接取数组头（否则也得不到优化复杂度的目的），而数组头不一定字典序最小 而什么容器可以维护字典序呢？ 我听见你在说：“set！ 优先队列！！！” 这是因为： 较之于队列，优先队列的不同在于它每一次取值取的是队列中的最大（小）值 那么，我们可以用小根堆维护一个优先队列（STL万岁！） 这样可以在O(1)的复杂度内找到字典序最小的入度为0的点 代码如下（按照最小字典序输出）复杂度为O(n+e)： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #define maxn 500010 using namespace std; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;hp;//STL小根堆 int n,m; int rd[maxn],ans[maxn]; struct star{ int next,to; }a[maxn]; int h[maxn],top; void add(int x,int y) { a[++top].to=y; a[top].next=h[x]; h[x]=top; return; } int tp() { for(int i=1; i&lt;=n; i++) { if(rd[i]==0) hp.push(i);//入堆 } while(!hp.empty()) {//堆非空 int x=hp.top(); hp.pop();//取出堆顶 ans[++ans[0]]=x; for(int i=h[x]; i; i=a[i].next) { int y=a[i].to; rd[y]--; if(rd[y]==0) hp.push(y);//入度为0的点入堆 } } if(ans[0]!=n) return 0;//有入度为0的点未取出，即有环 return 1; } int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=m; i++) { int x,y; cin&gt;&gt;x&gt;&gt;y; add(x,y);//前向星存储 rd[y]++;//统计入度 } if(tp()) {//无环 for(int i=1; i&lt;=ans[0]; i++) { cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; } return 0; } cout&lt;&lt;&quot;NO SOLUTION&quot;&lt;&lt;endl;//有环 return 0; } 变形题：1465 -- 【拓扑排序】奖金 [问题描述] 由于无敌的凡凡在2005年世界英俊帅气男总决选中胜出，Yali Company总经理Mr.Z心情好，决定给每位员工发奖金。公司决定以每个人本年在公司的贡献为标准来计算他们得到奖金的多少。 于是Mr.Z下令召开m方会谈。每位参加会谈的代表提出了自己的意见：“我认为员工a的奖金应该比b高！”Mr.Z决定要找出一种奖金方案，满足各位代表的意见，且同时使得总奖金数最少。每位员工奖金最少为100元。 [文件输入] 第一行两个整数n,m，表示员工总数和代表数； 以下m行，每行2个整数a,b，表示某个代表认为第a号员工奖金应该比第b号员工高。 [文件输出] 若无法找到合理方案，则输出“Poor Xed”；否则输出一个数表示最少总奖金。 [样例输入] 2 1 1 2 [样例输出] 201 [数据规模] 80％的数据满足n&lt;=1000，m&lt;=2000； 100％的数据满足n&lt;=10000，m&lt;=20000。 首先构图，若存在条件&quot;a的钱比b多&quot;则从b引-条有向指向a；然后拓扑排序，若无法完成排序则表示问题无解(存在圈)；若可以得到完整的拓扑序列，则按序列顺序进行递推： 设 f[i] 表示第i个人能拿的最少奖金数； 首先所有f[i] =100(题目中给定的最小值)； 然后按照拓扑顺序考察每个点i，若存在有向边(j,i),则表示们必须比f[j]大，因此我们令f[i] = Max { f[i]，f[j]+1 }即可； 递推完成之后所有f[i]的值也就确定了，而答案就等于f[1]+... +f[n]。 代码如下（按照最小字典序输出）复杂度为O(n*e)： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #define maxn 500010 using namespace std; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;hp;//STL小根堆 int n,m; int rd[maxn],ans[maxn]; struct star{ int next,to; }a[maxn]; int h[maxn],top; void add(int x,int y) { a[++top].to=y; a[top].next=h[x]; h[x]=top; return; } int tp() { for(int i=1; i&lt;=n; i++) { if(rd[i]==0) hp.push(i);//入堆 } int topp=0; while(!hp.empty()) {//堆非空 int x=hp.top(); hp.pop();//取出堆顶 topp++; for(int i=h[x]; i; i=a[i].next) { int y=a[i].to; rd[y]--; ans[y]=max(ans[y],ans[x]+1); if(rd[y]==0) { hp.push(y);//入度为0的点入堆 } } } if(topp!=n) return 0;//有入度为0的点未取出，即有环 return 1; } int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) { ans[i]=100; } for(int i=1; i&lt;=m; i++) { int x,y; cin&gt;&gt;x&gt;&gt;y; add(y,x);//前向星存储 rd[x]++;//统计入度 } if(tp()) {//无环 int sum=0; for(int i=1; i&lt;=n; i++) { sum+=ans[i]; } cout&lt;&lt;sum; return 0; } cout&lt;&lt;&quot;Poor Xed&quot;&lt;&lt;endl;//有环 return 0; } 拓扑排序概念内容引自简书 图片来源：简书、百度百科 题目来源：Did及Xinyue 代码：GMQ原创出品 代码与堆优化详解：GMQ原创出品 有转载需求请私信：gao.maoqi.2007@foxmail.com ","link":"https://gaomaoqi.github.io/post/tu-lun-suan-fa-tuo-bu-pai-xu/"},{"title":"空客A320","content":"总体介绍 空客A320系列（英语：Airbus A320 family）是空客公司制造的一系列中短程双发动机窄体客机，系列成员包括A318、A319、A320、A321以及商务客机ACJ，是空客最畅销的产品。 A320于1988年推出，是第一款使用数字线传飞行控制系统的商用飞机。 2019年11月，A320的订单数目（15,193架）超越737客机（15,136架），成为航空历史上销量最高的客机。不过，737的实际交付量（10,563架）仍领先A320（9,086架）。 主要用户 美国航空 易捷航空 中国东方航空 中国南方航空 中国国际航空 香港快运航空 中华人民共和国星宇航空 靛蓝航空 达美航空 捷蓝航空 系列 A320家族飞机采用通用设计，有小一点的A319、更小一点的A318、或者大一些的A321，最近推出了改进版A320Neo（冲击了C919市场）和A319Neo，它们彼此的操作方式相同。载客量从100至220人不等。主要竞争对手是波音737系列和中国商飞C919。 A320 A320系列有两个型号，分别是A320-100和A320-200。 A320-100产量很少，只生产了22架，最初用户只有因特航空（后来被法国航空合并）和英国航空（英航的A320-100由英国金狮航空在结业前订购）。 A320-200是主要型号。其特征是翼尖上的小翼和为增加巡航距离而增大的油箱，基本上-100和-200的分别很少，两者的载客量、机舱内部、长宽度等也是相同的。A320-200可以运载150名乘客，巡航距离约2900海里（5400千米），使用2台CFM国际的CFM56-5或国际航空发动机V2500发动机，推力25500到27000磅（113-120千牛顿力）。 A320的竞争机型是波音737-800。 A319 美国航空为A319的最大用户 这是缩小的A320更改版本。由于使用与A320-200相同的燃料容积以及较低的载客量，即2等式布局情况下124名乘客，使得它的航程可以达到3900海里（7200千米），是这个系列中，航程最长的型号。在整个A320系列中，A320和A319是最经常被改装的。在2003年，易捷航空将旗下的A319型飞机改装了小型厨房（之前易捷航空不提供机上餐食），并将剩余的位置采用了单一座位布局，以运载156名乘客。为符合逃生规定的要求，他们甚至在机翼上新增了逃生门，便于利用机舱的中间部分。 易捷航空先行订购了120架A319系列，之后又增加了120架。这是近期航空史上最大的销售案例。这也确立了一个先例，即A320家族可能比原来的选择（即波音737），不论是全新的，还是二手的，都更加经济。 A319与A320使用同款发动机。1996年4月，它通过了欧洲联合航空署认证，同时加入了瑞士航空的机队。实际上，A319的首发用户是国际租赁财务公司，它在1993年订购了6架A319。A319的竞争机型是波音737-700。 A321 中国南方航空是继美国航空后A321的第二大用户 A321的驾驶舱与A318、A319及A320相似。此设计与A330、A340、A350及A380相近，此共通性可加快飞行员操作其他机型间的转训时间。这也是第一个使用侧置操纵杆（side-stick）与数字电传操纵（fly-by-wire）飞行控制系统技术的商业民航客机 A320的加长型。机翼面积略为扩大，起落架被加固，使用高推力CFM56和V2500发动机。有些航空公司购买A321代替波音757，因为A321机师的资格证书是与A318、A319和A320共享的。1993年12月，FAA开始颁发系列飞机机师认证。 典型的2等式座舱可以运载185名乘客，巡航距离约2,300海里（4,300千米）。使用2台CFM56-5A或者IAE V2500发动机，最大推力31,000磅（138千牛顿力）。 A321-200增加了燃料箱容量，同样可以运载185名乘客，但是巡航距离提高到3,000海里（5500千米）。A321-200使用2台CFM56-5或IAE V2500发动机，最大推力33,000磅（148千牛顿力）。截至2016年9月，共有1,376架A321已经交付，347架仍未交付。A321的竞争机型是波音737-900/900ER和波音757。 A318 法国航空为A318的最大用户 A318，也叫&quot;迷你空客&quot;，是A320家族中最小的成员。在空客工业公司亚洲部、中国航空工业公司和新加坡科技有限公司的合作开发项目AE31X[9]取消后宣布引导。在开发阶段时使用代号是“A319M3”[10]，我们从这里便可以看出A318其实是由A319直接派生出来的。“M3”表示“减去3处机身结构”。这一类型比标准型短了6米，轻了14吨。凡是接受过A320型飞机训练的机师可以不用获取额外的认证就可以驾驶A318，因为它的特性跟它的姊妹机型是大致上一样的。 A318在2个级别客舱配置下可以搭载109名乘客，可以替代早期的波音737和道格拉斯DC-9型，同时也是现在的737-600和717（本质上是DC-9改进）的竞争对手。截至2016年9月共生产了80架。 A318可提供最大起飞重量（MTOW）59吨－68吨，最大巡航距离2,750千米（1,500海里）－6,000千米（3,250海里）的不同配置。低起飞重量牺牲了巡航能力换来更加经济的支线实行能力；高起飞重量弥补了A320家族边际航线的适应能力。A318比A320更轻的重量能给它的巡航距离带来大约10%的提升，这样它就可以在一些A320服务不到的航在线服务：例如伦敦城市机场。这一型号主要用于中型城市之间的短程，低停留密度航线。 A318与A320家族其他型号相比有个主要的不足就是货舱门相对标准集装箱来说是太小，这样不能如其他A320型号装载LD3货柜，几乎没有可能运载大一点的货物。 处于设计阶段，A318就碰到了好几块绊脚石。首先就是911以后对新飞机的需求急剧下降。另外一个就是普惠（Pratt &amp; Whitney）新研制的涡轮风扇发动机耗油量比预期高：同时通用电气公司效率更高的发动机投放市场，令许多A318客户因此收回订单，其中有中国国际航空公司，美国航空和英国航空。虽然空客希望A318面向支线飞机市场，但美国和欧洲不少机场，都是把它按照大型客机的标准收取着陆费，而区域航空公司已经避免这种情况发生。 改型由2台CFM56-5或普惠PW6000发动机提供21,600到23,800磅f（96到106千牛顿力）推力。边疆航空，美西航空和法国航空这些最初用户于2003年开始接收，边疆航空于当年7月接收第一架飞机。A318价格大约是3900-4500万美元，日常飞行大约花费3,000美元/500英里。A318的竞争机型是波音737-600。 除了作为支线飞机外，A318亦用作重型公务机，并有包括一二三航空在内的若干公务机公司正在营运这款客机。 机型 A318-100 A319-100 A320-200 A321-200 驾驶员数 2 2 2 2 座位数 132（1级最大） 117（1级典型） 107（2级典型） 156（1级最大） 134（1级典型） 124（2级典型） 186（1级最大） 164（1级典型） 150（2级典型） 230（1级最大） 199（1级典型） 185（2级典型） 长度 31.44米（103呎2吋） 33.84米（111呎） 37.57米（123呎3吋） 44.51米（146呎） 翼展 34.10米（111呎11吋） 机翼面积 122.6平方米（1,320平方英尺） 后掠翼 25° 高度 12.51米（41呎1吋） 11.76米（38呎7吋） 客舱宽度 3.70米（12呎1吋） 客舱长度 21.38米（70呎2吋） 23.78米（78呎） 27.51米（90呎3吋） 34.44米（113呎） 机身宽度 3.95米（13呎） 机身高度 4.14米（13呎7吋） 轴距 10.25米（33呎8吋） 11.04米（36呎3吋） 12.64米（41呎5吋） 16.91米（55呎4吋） 轮距 7.59米（24呎11吋） 空重 39,500千克（87,100磅） 40,800千克（89,900磅） 42,600千克（93,900磅） 48,500千克（106,900磅） 最大起飞重量 68,000千克（149,900磅） 75,500千克（166,400磅） 78,000千克（172,000磅） 93,500千克（206,100磅） 最大落地重量 57,500千克（126,800磅） 62,500千克（137,800磅） 66,000千克（145,500磅） 77,800千克（171,500磅） 巡航速率 0.78马赫（828千米/小时、515英里/小时、447节 于 11,000米/36,000英尺巡航高度） 最大速率 0.82马赫（871千米/小时、541英里/小时、470节 于 11,000米/36,000英尺巡航高度） 起飞所需跑道长度（于最大起飞重量时） 1,828米（5,997呎） 2,164米（7,100呎） 2,090米（6,860呎） 2,560米（8,400呎） 满载航距 5,950千米（3,200海里） 6,850千米（3,700海里） 6,150千米（3,300海里） 5,950千米（3,200海里） 最大燃油容量 24,210升（6,400美国加仑） 30,190升（7,980美国加仑） 30,030升（7,935美国加仑） 实用升限 12,000米（39,000呎） 发动机（x2） CFM International CFM56-5B 普惠（Pratt &amp; Whitney）PW6000A International Aero Engines IAE V2500-A5 发动机推力（x2） 98至107千牛顿（22,000至24,000磅） 120/98千牛顿（27,000/22,000磅） 148/120千牛顿（33,000/27,000磅） 表格来源：维基百科 图片来源：百度图片，维基百科，航空摄影图库 ","link":"https://gaomaoqi.github.io/post/kong-ke-a320/"},{"title":"美国也爱社会主义你信吗","content":"转载自continue的博客：美国也爱社会主义你信吗 总所周知，美国是一个热爱搞事情自由的国家。 如果这个世界是一个游戏，那么美国这个玩家的buff应该叫祖安人“言论自由”。 所以到底什么是“言论自由”呢？ 首先来说说自由吧。 我们所熟知的社会主义，所对应的其实还有自由主义。在某些方面上，两者几乎是完全相反的。 就纳税这件事来说。自由主义认为纳税就是拿勤奋的人自己辛辛苦苦挣的钱来救济懒惰的人，这在他们看来是非常愚蠢的。实际上，所谓“勤奋的人”就是有钱人，而所谓“懒惰的人”，其实是那些贫穷的底层民众。 自由主义大多数认同**“丛林法则”，即弱肉强食**。他们认为这个社会就应该择优，最底层的人基本上就无法拥有生存的权力。 这就使得有钱的人越有钱，贫穷的人也得不到基本的生活保障。曾有人做过统计，美国财富金字塔顶尖的**1%的财富，比90%**底层人民的财富总和加起来还多。这就是所谓的“自食其力”造成的社会现象。 而社会主义相比之下就非常厚道了。**社会主义讲求人人平等。**你有钱，没问题。能力越大责任越大，反正你就得为做一份对得起你价值的贡献。于是乎，贫穷的人纳税少或者根本不纳税，有钱的人就多拿一点出来，反正你一个人享受着那也不叫个事。从有钱人那里得到的钱，就造福社会。你穷就有贫困补贴，你没钱看病就有医保。这样底层人民有了保障，GDP就升，有钱人的钱就又多了，纳的税就水涨船高，整个社会进入了一个良性循环。 当然，自由主义到现在还被美国这种大国运用，说明它也有它的好处。这种制度也不一定就是饿死人的，它也有可能激发人。 简单地讲述了自由主义和社会主义，现在该来看看标题啦。 其实美国根本上是建设的自由主义之国，但它一直以来的一个信念是**【民主】**。而民主这个东西，从刚才纳税这个简单的问题来看，明显是社会主义的东西。民主也可以说是社会主义思想的一部分。所以呢，美国其实是择取了两个不同思想中它认为最优，最适合国家发展的观念融会贯通，才形成了在特朗普瞎指挥下领导都还能存活在数百年内称霸地球的一套独特思想。 不同的历史背景往往造就不同的一套统治思想。在我们看美国佬在外交部胡扯什么“言论自由”的时候，也要理性地看待这群自♂由的人儿。 ","link":"https://gaomaoqi.github.io/post/mei-guo-ye-ai-she-hui-zhu-yi-ni-xin-ma/"},{"title":"朋友们","content":"感谢我的朋友们，没有他们就没有这个博客，我也会比现在弱的多 yuzhenghao 与我是同道中人（民航），他的博客是使我决定建博客的根本原因。 gaobeifan2022 帮我无数次康代码，康完代码只留下一句： continue 促使我搭成了这个博客，无私地向我和GBF提供许多资料 ","link":"https://gaomaoqi.github.io/post/peng-you-men/"},{"title":"大事记","content":"这个博客创建以来的更新 2020.3.19 评论功能上线 搜索功能上线 2020.3.18 更新主题。 2020.3.17 搭建完成，开始运行。 ","link":"https://gaomaoqi.github.io/post/da-shi-ji/"},{"title":"【关于】 Hello,World!（食用必读）","content":"在浏览本站前，请先务必阅读此篇文章。 已经有名大佬踩了当前页面。。。 关于我和我的博客 我是谁 一名OIer，坐标重庆，喜欢民航。 e-mail：gao.maoqi.2007@foxmail.com luogu：gaomaoqi2022 github：gaomaoqi 我的博客 博客主要涉及信息学题解、信息学学习笔记以及民航等方面。 不定时更新，有灵感就更新。 另外，我是C++党，所以你所见到的代码几乎都是C++的，略懂Python，以及精通Scratch。 大事记 2020.3.17，搭建完成，开始运行。 2020.3.18，更新主题。 2020.3.19，评论、搜索功能上线。 My friends yuzhenghao的luogu主页 yuzhenghao's blog gaobeifan2022的luogu主页 continue的luogu主页 注：进入我的博客请都使用谷歌浏览器，并定期按Ctrl+Shift+R去缓存 ","link":"https://gaomaoqi.github.io/post/helloworld/"},{"title":"飞机，你感冒了么？","content":"人有时会感冒，感冒之后人们一般戴上口罩。这样呼吸的空气是热的，能舒服一些。 可是，有些飞机也戴着口罩，难道它是感冒了么？ 飞机是铁疙瘩，当然没有感冒这回事。飞机戴的“口罩”是雷达罩，确切地说，是雷达的“整流罩”。 所谓“整流罩”，作用就是“整理气流”。它是个“壳壳”，里头没有东西。 取掉了整流罩的飞机头，一般是这样的： 图：CRJ-200飞机去掉整流罩之后 虽然不是什么值钱部件，但雷达的整流罩在飞机的最前端，当飞机以900多公里的时速飞行时，磨损比较大，容易掉漆。如果在空中发生撞鸟等事故，它往往首先遭殃。它一旦变形就会影响气流，就像汽车的前轮亏气会影响方向一样，所以必须处理——更换！ 整流罩在飞机上也算是“易损部件”。好在它的价格不贵，各家公司虽然业务竞争，但遇到来借雷达罩的，一般都会帮忙。除非你是空客我是波音，借给你也没法用…… 因为借来借去，所以你能看到飞机戴着各种奇怪的“口罩”。 虽然借来借去，但实际上大部分“口罩”都是自家的。自家为什么会有两种颜色的“口罩”呢？ 如果所有的航空公司从来不更换涂装，又从来都只用自家的雷达罩，你是不会有机会看到“飞机戴口罩”的。但如果一个公司有两种涂装，例如像东航这样六七年过去了还没有完成涂装更新，你就经常能看到它家的飞机“戴口罩”。 虽然都是自家的，但东航的一种涂装是“三线”，一种涂装是“纯白”。凑到一起时，当然就“戴了口罩”了。 这样的例子很多。例如深圳航空的这架波音737-300在当时刚换了新装，但不巧用了一个旧款的雷达罩。 还有美联航在换了“翻肚皮”涂装之后，依然在使用原来“霸气灰”涂装的雷达罩。 以及海南航空剃了胡子之后，却还在使用原来的“小胡子”雷达罩——这很好玩，这可就不是“美髯胡“，而是彻底的“仁丹胡”啦！ 那它原本的“新口罩”哪儿去了呢？——原来在这里！ 因为换装导致“飞机戴口罩”的还有厦门航空。虽然“新装”与“旧装”变化不大，但是一个曲线的更改，就会引发“口罩效应”。 当然就算是同样的“口罩”，想要每架飞机的雷达罩都严丝合缝，也非常困难。毕竟，谁家喷涂时，还拿着游标卡尺在那儿量呢！ 机队中有“特殊涂装（包括彩绘）”是导致“飞机戴口罩”的另一主要原因。特别是国航南航这种大公司，机队有大量的“星空联盟”或者“天合联盟”的涂装。一时没有来得及给雷达罩重新喷漆时，就只能戴着颜色不匹配的口罩四处跑。嗬，这叫一个拉风！ 国航虽然是载旗航空，但却是最不讲面子的。只要挣钱，管它穿啥衣服，戴啥口罩！ 所以就算是远程大家伙，重型机，照样“戴着口罩”满世界跑，好几个月都不换喔！ 不仅是国航，就连很注意形象的海航也免不了偶尔客串一下雷达罩。瞧这个红鼻子，如果再配个彩绘，是不是就可以叫做“红鼻子阿义”了。 不仅载旗航空，就连廉价航空也免不了俗套。 只是很让人疑惑，春秋航空都是白衣服，这灰灰的口罩，是哪里借回来的哩？ 而且，灰口罩还挺多。连日本的乐桃航空也戴灰口罩，难道这是空客作为备件出厂时的颜色？ 首都航空虽然属于海航集团，但毕竟顶着“首都”的名号。找国航借个口罩戴戴，看来轻而易举嘛！ 还有属于东航集团的中国货运航空，也去找国航借口罩了~~ 但山东航空这个，很稀罕。无论如何也想不起来，这种口罩应该是谁家的。 只有这个口罩不是借的，是自己拿毛笔画的。在2006年德国世界杯期间，汉莎航空把自己的雷达罩都涂成了足球，风趣有加！ QAQ求点赞 ","link":"https://gaomaoqi.github.io/post/fei-ji-ni-gan-mou-liao-me/"}]}